###### 거스름돈
# 500, 100, 50, 10
# 손님에게 거슬러 주어야 할 돈이 N
# 거슬러 주어야 할 동전의 최소 개수

# 가장 큰 화폐 단위부터 돈을 거술러 주면 됨

# ex
# n = 1260
# count = 0
#
# array = [500, 100, 50, 10]
#
# for coin in array:
#     count += n // coin  # // 연산자 소수점 이하 버린 값 count = count + n // coin
#     n %= coin  # n = n % coin
#
# print(count)

# 정당성 분석
# 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문

# 만약 화폐 단위가 500 400, 100 인데 800을 거술러 주어야 한다면??
# 그리디 알고리즘 문제에서는 ㅣㅇ처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 한다.


##### 1이 될 때까지:
# 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 단, 두 번쨰 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다.
# N에서 1을 뺀다
# N을 K로 나눈다.
# 최소 횟수를 구하라.

# global cnt
# cnt = 0
#
#
# # 재귀
# def for_one(n, k):
#     global cnt
#     if n == 1:
#         return cnt
#
#     if n % k == 0:
#         cnt += 1
#         for_one(n // k, k)
#     else:
#         cnt += 1
#         for_one(n - 1, k)
#
#     return cnt
#
#
# global result
# result = 0
#
#
# def for_one2(n, k):
#     global result
#     while True:
#         target = (n // k) * k
#         result += (n - target)
#         n = target
#
#         if n < k:
#             break
#
#         result += 1
#         n //= k
#
#     result += (n - 1)
#     return result
#
#
# print(for_one(383574334612341232131, 126))
# print(for_one2(383574334612341232131, 126))

##### 곱하기 혹은 더하기 :
# 각 자리가 숫자 0 ~ 9 로만 이루어진 문자열 S가 주어졌을 떄, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에  * or + 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하시오
# 단 + 보다 *를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서붜 순서대로 이루어진다고 가정한다.
# ex) 02984 -> (((( 0 + 2) * 9 ) * 8 ) * 4 ) = 576

